'use strict';

        /* INFO */
    // creates a hash table to store objects
    // keys are generated by using the general location passed into the hash function

        /* FUNCTIONS */
    // insert -> inserts an object into the hash table
        // takes an object, returns whether it was added or not
        // will create the bin if needed
        // if an object will fill more than one bin, inserts it into all of them
    // remove -> takes an object out of the hash table
        // takes an object to remove
        // will delete the bin if it's no longer needed
    // addBin -> takes an index and creates a new bin
        // takes the key index
    // removeBin -> takes the bin index to remove
        // takes an index
    // hashIn -> calculates the key
        // takes an object with a position to create the key
    // hashOut -> calculates the position based on a key
        // takes a key to create a position


function physicalHash(size) {
     
            /* PROPERTIES */
        // public
    
        // private
    var proto = physicalHash.prototype;                 // prototype for adding functions
    
    this.cellSize = size || 1;                  // size of bins
    
    this.cellConversion = 1 / this.cellSize;    // conversion for hashing
    
    this.type = 'physical';             // style of bin intersection
    
    this.bins = new Map();                      // array of storage bins
    
            /* PROTOTYPE FUNCTIONS */
    // insert function
    proto.insert = function (obj) {
        if (obj === undefined) {
            //console.log('object was undefined');
            return false;               // no object passed in
        }
            
        var keys = this.hashIn(obj);     // get the hash key
        
        if (keys === undefined) {
            //console.log('keys was undefined');
            return false;               // no key could be made
        }
        
        for (var i = 0; i < keys.length; i++) {
            if (this.bins.has(keys[i])) {             // check if the bin exists
                // insert the object into the bin
                this.bins.get(keys[i])[this.bins.get(keys[i]).length] = obj;
            } else {
                // bin doesn't exist
                if (this.addBin(keys[i])) {
                    // insert the object into the new bin
                    this.bins.get(keys[i])[0] = obj;

                } else {
                    //console.log('bin could not be created');
                    //console.dir(keys[i]);
                    return false;
                }
            }
        }
        
        obj[this.type].keys = keys;
        
        return true;                   // fall through pass
        
    };
    // remove object function
    proto.remove = function (obj) {if (obj === undefined) {
            //console.log('object was undefined');
            return false;               // no object passed in
        }
            
        var keys = this.hashIn(obj);     // get the hash key
        
        if (keys === undefined) {
            //console.log('keys was undefined');
            return false;               // no key could be made
        }
        
        for (var i = 0; i < keys.length; i++) {
            if (this.bins.has(keys[i])) {             // check if the bin exists
                // insert the object into the bin
                if (index > -1) {
                    this.bins.get(keys[i]).splice(index, 1);        // remove object

                    if (this.bins.get(key).length == 0) {
                        // bin is now empty, remove it
                        this.removeBin(key);
                    }
                }
            }
        }
        
        return true;
    };
    // create a new bin
    proto.addBin = function (key) {
        if (key === undefined)
            return false;               // no key to add
        
        if (this.bins.has(key))
            return false;               // bin already existed
        
        this.bins.set(key, []);
        return true;
    };
    
    proto.removeBin = function (key) {
        if(key === undefined)
            return false;
        
        this.bins.delete(key);
        
        return true;
    };
    
    proto.hashIn = function (obj) {
        var keys = [];
        
        // properties of the object using AABB
        var min = {
            x: Math.floor(obj[this.type].min.x * this.cellConversion),
            y: Math.floor(obj[this.type].min.y * this.cellConversion)
        };
                          
        var max = {
            x: Math.floor(obj[this.type].max.x * this.cellConversion),
            y: Math.floor(obj[this.type].max.y * this.cellConversion)
        };
        
        // get all cells the object is in
        for (var i = 0; i <= max.x - min.x; i++) {
            for (var j = 0; j <= max.y - min.y; j++) {
                keys[keys.length] = JSON.stringify({x: min.x + i, y: min.y + j});
            }
        }
        
        return keys;
    };
    
    proto.hashOut = function (key) {
        
    };
    
    // gets all the children from this bin
    proto.getBin = function (key) {
        if (!this.bins.has(key))
            return undefined;               // key does not exist
        
        return this.bins.get(key);
    };
    
    proto.getBinLength = function (key) {
        if (!this.bins.has(key))
            return undefined;               // key does not exist
        
        return this.bins.get(key).length;
    };
    
    proto.getTotalBinCount = function () {
        return this.bins.size;
    };
    
    // returns all the keys of the bins
    proto.getKeys = function() {
        return this.bins.keys();
    }
    
    // clears all the bins and resets the hash tables
    proto.clear = function (key) {
        if (key === undefined) {        // clear the entire hash table
            this.bins.clear();
        } else {
            if (this.bins.has(key)) {   // bin exists, remove it
                this.bins.delete(key);
                this.masses.delete(key);
            }
        }
    };
    
    // returns all the bins
    proto.getAllBins = function () {
        return this.bins;
    }
    
    // changes the hash size to be more optimal depending on how many objects there are
    proto.updateHashSize = function (relation, curCount) {
        this.cellSize = relation / curCount
        this.cellConversion = 1 / this.cellSize;
    }
};