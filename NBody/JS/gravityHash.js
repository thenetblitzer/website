'use strict';

        /* INFO */
    // creates a hash table to store objects
    // keys are generated by using the general location passed into the hash function

        /* FUNCTIONS */
    // insert -> inserts an object into the hash table
        // takes an object, returns whether it was added or not
        // will create the bin if needed
        // if an object will fill more than one bin, inserts it into all of them
    // remove -> takes an object out of the hash table
        // takes an object to remove
        // will delete the bin if it's no longer needed
    // addBin -> takes an index and creates a new bin
        // takes the key index
    // removeBin -> takes the bin index to remove
        // takes an index
    // hashIn -> calculates the key
        // takes an object with a position to create the key
    // hashOut -> calculates the position based on a key
        // takes a key to create a position


function gravityHash(size) {
     
            /* PROPERTIES */
        // public
    
        // private
    var proto = gravityHash.prototype;                 // prototype for adding functions
    
    this.cellSize = size || 1;                  // size of bins
    
    this.cellConversion = 1 / this.cellSize;    // conversion for hashing
    
    this.type = 'gravitational';                // style of bin intersection (gravity or physical)
    
    this.bins = new Map();                      // array of storage bins
    
    this.masses = new Map();
    
            /* PROTOTYPE FUNCTIONS */
    // insert function
    proto.insert = function (obj) {
        if (obj === undefined) {
            //console.log('object was undefined');
            return false;               // no object passed in
        }
            
        var key = this.hashIn(obj);     // get the hash key
        
        if (key === undefined) {
            //console.log('key was undefined');
            return false;               // no key could be made
        }
        
        if (this.bins.has(key)) {             // check if the bin exists
                // insert the object into the bin
                this.bins.get(key)[this.bins.get(key).length] = obj;
                if (obj.physical != undefined && obj.physical.mass != undefined) {
                    // figure out the center of mass of the bin
                    var cog = {
                        x: this.masses.get(key).position.x,
                        y: this.masses.get(key).position.y
                    };
                    var totalMass = this.masses.get(key).mass + obj.physical.mass;
                    var massPercent = this.masses.get(key).mass / totalMass;
                    this.masses.set(key, {mass: totalMass,
                                          position: {
                                            x: cog.x * massPercent + obj.position.x * (1 - massPercent),
                                            y: cog.y * massPercent + obj.position.y * (1 - massPercent)
                                          }
                                         });
                }
            } else {
                // bin doesn't exist
                if (this.addBin(key)) {
                    // insert the object into the new bin
                    this.bins.get(key)[0] = obj;
                    if (obj.physical != undefined && obj.physical.mass != undefined) {
                        this.masses.set(key, {mass: obj.physical.mass,
                                              position: {
                                                x: obj.position.x,
                                                y: obj.position.y}
                                             });
                    }

                } else {
                    //console.log('bin could not be created');
                    //console.dir(key);
                    return false;
                }
            }
        
        obj[this.type].keys = key;
        
        return true;                   // fall through pass
        
    };
    // remove object function
    proto.remove = function (obj) {if (obj === undefined) {
            //console.log('object was undefined');
            return false;               // no object passed in
        }
            
        var key = this.hashIn(obj);     // get the hash key
        
        if (key === undefined) {
            //console.log('key was undefined');
            return false;               // no key could be made
        }
                                   
        if (this.bins.has(key)) {             // check if the bin exists
            // remove the object from the bin
            var index = this.bins.get(key).indexOf(obj);
            
            if (index > -1) {
                this.bins.get(key).splice(index, 1);        // remove object
                this.masses.delete(keys[i]);                    // remove object

                if (this.bins.get(key).length == 0) {
                    // bin is now empty, remove it
                    this.removeBin(key);
                }
            }
        }
        
        return true;
    };
    // create a new bin
    proto.addBin = function (key) {
        if (key === undefined)
            return false;               // no key to add
        
        if (this.bins.has(key))
            return false;               // bin already existed
        
        this.bins.set(key, []);
        this.masses.set(key, { });
        
        return true;
    };
    
    proto.removeBin = function (key) {
        if(key === undefined)
            return false;
        
        this.bins.delete(key);
        this.masses.delete(key);
        
        return true;
    };
    
    proto.hashIn = function (obj) {
        var key;
        
        // properties of the object using AABB
        var pos = {
            x: Math.floor(obj.position.x * this.cellConversion),
            y: Math.floor(obj.position.y * this.cellConversion)
        };
        
        // get bin the object is in
        key = JSON.stringify({x: pos.x, y: pos.y});
        return key;
    };
    
    proto.hashOut = function (key) {
        
    };
    
    // gets all the children from this bin
    proto.getBin = function (key) {
        if (!this.bins.has(key))
            return undefined;               // key does not exist
        
        return this.bins.get(key);
    };
    
    // specific to grav hash, returns the center of mass and total mass for gravitation
    proto.getBinMassObject = function (key) {
        if (!this.bins.has(key))
            return undefined;
        
        return this.masses.get(key);
    };
    
    // returns how many objects are in a specific bin
    proto.getBinLength = function (key) {
        if (!this.bins.has(key))
            return undefined;               // key does not exist
        
        return this.bins.get(key).length;
    };
    
    // returns how many bins there are
    proto.getTotalBinCount = function () {
        return this.bins.size;
    };
    
    // returns the keys of the bins
    proto.getKeys = function() {
        return this.bins.keys();
    };
    
    // returns the bins
    proto.getAllBins = function () {
        return this.bins;
    };
    
    // specific to grav hash, set ths gravitation of all the bins
    proto.finalize = function () {
        var keys = Array.from(this.masses.keys());
        for (var i = 0; i < keys.length; i++) {
            this.masses.get(keys[i]).graviationalRadius = this.masses.get(keys[i]).mass / 10;
        }
    }
    
    // clears all the bins and resets the hash table
    proto.clear = function (key) {
        if (key === undefined) {        // clear the entire hash table
            this.bins.clear();
            this.masses.clear();
        } else {
            if (this.bins.has(key)) {   // bin exists, remove it
                this.bins.delete(key);
                this.masses.delete(key);
            }
        }
    };
    
    // changes the hash size to be more optimal depending on how many objects there are
    proto.updateHashSize = function (relation, curCount) {
        this.cellSize = relation / curCount
        this.cellConversion = 1 / this.cellSize;
    }
    
};